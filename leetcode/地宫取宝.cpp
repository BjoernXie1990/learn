#include <iostream>
#include <cstring>

using namespace std;

const int N = 55, M = 15;
const int mod = 1e9 + 7;
int n,m,k;
int f[N][N][M][M];  // f[i][j][nn][mm]  i,j 时 有nn个物品，且最大价值为mm 的方案数
int t[N][N];

int main() {
    cin >> n >> m >> k;
    for(int i = 1; i <= n; i++)
        for(int j = 1; j <= m; j++) {
            cin >> t[i][j];
            t[i][j] ++;     // 对于一个物品，不选的话，他带来的价值为0。而原本价值的范围为0-12，这样就可以变成1-13
        }
    
    f[1][1][0][0] = 1;              // 不选 1,1 的物品
    f[1][1][1][t[1][1]] = 1;    // 选1,1 的物品
    for(int i = 1; i <= n; i++)
        for(int j = 1; j <= m; j++)
            for(int nn = 0; nn <= k; nn++)
                for(int mm = 0; mm < M; mm++) {
                    // 不取 i,j
                    f[i][j][nn][mm] = ((f[i][j][nn][mm] + f[i-1][j][nn][mm]) % mod + f[i][j-1][nn][mm]) % mod;
                    
                    // 取i,j  得保证当前状态的最大价值为 mm
                    if(nn > 0 && mm == t[i][j]) {
                        // 从之前的最大值 0 - mm 变迁
                        for(int s = 0; s < mm; s++)
                            f[i][j][nn][mm] = ((f[i][j][nn][mm] + f[i-1][j][nn-1][s]) % mod + f[i][j-1][nn-1][s]) % mod;
                    }
                }
    
    int ans = 0;
    for(int i = 1; i <= 13; i++) ans = (ans + f[n][m][k][i]) % mod;
    cout << ans;
    return 0;
}


X 国王有一个地宫宝库，是 n×m 个格子的矩阵，每个格子放一件宝贝，每个宝贝贴着价值标签。

地宫的入口在左上角，出口在右下角。

小明被带到地宫的入口，国王要求他只能向右或向下行走。

走过某个格子时，如果那个格子中的宝贝价值比小明手中任意宝贝价值都大，小明就可以拿起它（当然，也可以不拿）。

当小明走到出口时，如果他手中的宝贝恰好是 k 件，则这些宝贝就可以送给小明。

请你帮小明算一算，在给定的局面下，他有多少种不同的行动方案能获得这 k 件宝贝。

输入格式
第一行 3 个整数，n,m,k，含义见题目描述。

接下来 n 行，每行有 m 个整数 Ci 用来描述宝库矩阵每个格子的宝贝价值。

输出格式
输出一个整数，表示正好取 k 个宝贝的行动方案数。

该数字可能很大，输出它对 1000000007 取模的结果。

数据范围
1≤n,m≤50,
1≤k≤12,
0≤Ci≤12
输入样例1：
2 2 2
1 2
2 1
输出样例1：
2
输入样例2：
2 3 2
1 2 3
2 1 5
输出样例2：
14
