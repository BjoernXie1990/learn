//问题描述
//　　如果一个序列的奇数项都比前一项大，偶数项都比前一项小，则称为一个摆动序列。即 a[2i]<a[2i-1], a[2i+1]>a[2i]。
//　　小明想知道，长度为 m，每个数都是 1 到 n 之间的正整数的摆动序列一共有多少个。
//输入格式
//　　输入一行包含两个整数 m，n。
//输出格式
//　　输出一个整数，表示答案。答案可能很大，请输出答案除以10000的余数。
//样例输入
//3 4
//样例输出
//14
//样例说明
//　　以下是符合要求的摆动序列：
//　　2 1 2
//　　2 1 3
//　　2 1 4
//　　3 1 2
//　　3 1 3
//　　3 1 4
//　　3 2 3
//　　3 2 4
//　　4 1 2
//　　4 1 3
//　　4 1 4
//　　4 2 3
//　　4 2 4
//　　4 3 4
//评测用例规模与约定
//　　对于 20% 的评测用例，1 <= n, m <= 5；
//　　对于 50% 的评测用例，1 <= n, m <= 10；
//　　对于 80% 的评测用例，1 <= n, m <= 100；
//　　对于所有评测用例，1 <= n, m <= 1000。

#include<iostream>
using namespace std;

const int mod = 10000; 
int dp[1005][1005] = {0};
//奇数列：表示当前长度为i的列，结尾数字大于等于j的个数
//偶数列：表示当前长度为i的列，结尾数字小于等于j的个数 

int m,n;


int main()
{
	cin>>m>>n;
	for(int i = 1; i <= n; i++)
		dp[1][i] = n - i + 1;
	
	for(int i = 2; i <= m; i++)
	{
		if(i & 1)
		{
			for(int j = n; j >= 1; j--)
				//dp[i-1][j-1] -->  i-1 势必为偶数，表示i-1的长度，结尾数字小于等于j-1的个数
				//那么第i位就是比j-1大的数，那么他的取值就是前面比他小的数 
				dp[i][j] = (dp[i-1][j-1] + dp[i][j + 1]) % mod;
		}
		else
		{
			for(int j = 1; j <= n; j++)
				//dp[i-1][j+1] -->  i-1 势必为奇数，表示i-1的长度，结尾数字大于等于j+1的个数
				//那么第i位就是比j+1小的数，那么他的取值就是前面比他大的数
				dp[i][j] = (dp[i - 1][j + 1] + dp[i][j - 1]) % mod;
		}
	}
	
	//for(int i = 1; i <= m; i++)
//	{
//		for(int j = 1; j <= n; j++)
//			cout<<dp[i][j]<<' ';
//		cout<<endl;
//	} 
//	
	if(m & 1)//奇数是求，当前位置比前一位大 
		cout<<dp[m][1]<<endl;//如果长度为奇数，计算时是从后向前叠加，输出dp[m][1] 
	else//偶数是求，当前位比前一位小 
		cout<<dp[m][n]<<endl; //如果长度为偶数，计算时是从前向后叠加，输出dp[m][n] 
	return 0;
} 
