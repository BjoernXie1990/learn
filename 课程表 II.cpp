//现在你总共有 n 门课需要选，记为?0?到?n-1。

//在选修某些课程之前需要一些先修课程。?例如，想要学习课程 0 ，你需要先完成课程?1 ，我们用一个匹配来表示他们: [0,1]

//给定课程总量以及它们的先决条件，返回你为了学完所有课程所安排的学习顺序。

//可能会有多个正确的顺序，你只要返回一种就可以了。如果不可能完成所有课程，返回一个空数组。

//示例?1:

//输入: 2, [[1,0]] 
//输出: [0,1]
//解释:?总共有 2 门课程。要学习课程 1，你需要先完成课程 0。因此，正确的课程顺序为 [0,1] 。
//示例?2:

//输入: 4, [[1,0],[2,0],[3,1],[3,2]]
//输出: [0,1,2,3] or [0,2,1,3]
//解释:?总共有 4 门课程。要学习课程 3，你应该先完成课程 1 和课程 2。并且课程 1 和课程 2 都应该排在课程 0 之后。
//?    因此，一个正确的课程顺序是?[0,1,2,3] 。另一个正确的排序是?[0,2,1,3] 。
//说明:

//输入的先决条件是由边缘列表表示的图形，而不是邻接矩阵。详情请参见图的表示法。
//你可以假定输入的先决条件中没有重复的边。

class Solution {
public:
    //dfs
    int num = 0;
    vector<int> findOrder1(int numCourses, vector<vector<int>>& prerequisites)
    {
        unordered_map<int,vector<int> > map;
        for(auto& eoch : prerequisites)
            map[eoch[1]].push_back(eoch[0]);

        vector<int> visit(numCourses,0);
        vector<int> ret;
     
        for(int i = 0; i < numCourses; i++)
            if(!dfs(map,ret,visit,i)) return {};
        reverse(ret.begin(),ret.end());
        return ret;
    }

    static bool dfs(unordered_map<int,vector<int> >& map,vector<int>& ret,vector<int>& visit,int index)
    {
        //说明构成了环
        if(visit[index] == 1) return false;
        if(visit[index] == -1) return true;//说明之前遍历过
        visit[index] = 1;
        
        for(auto& eoch : map[index])
            if(!dfs(map,ret,visit,eoch)) return false;
        
        visit[index] = -1;
        ret.push_back(index);
        return true;
    }
    

    //拓扑排序
    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites)
    {
        unordered_map<int,vector<int> > map;
        vector<int> idx(numCourses,0);//记录每一个点的入度
        for(auto& eoch : prerequisites)
        {
            map[eoch[1]].push_back(eoch[0]);
            idx[eoch[0]]++;
        }

        queue<int> que;
        for(int i = 0; i < numCourses; i++)
            if(idx[i] == 0) que.push(i);//入度为0的点入队
        vector<int> ret;
        while(!que.empty())
        {
            auto it = que.front();
            que.pop();
            ret.push_back(it);
            for(auto& eoch : map[it])
            {
                idx[eoch]--;
                if(idx[eoch] == 0) que.push(eoch);
            }
        }
        vector<int> tmp;
        return ret.size()==numCourses ? ret :tmp;
    }
};
