//给出两个整数?n?和?k，找出所有包含从?1?到?n?的数字，且恰好拥有?k?个逆序对的不同的数组的个数。

//逆序对的定义如下：对于数组的第i个和第?j个元素，如果满i?<?j且?a[i]?>?a[j]，则其为一个逆序对；否则不是。

//由于答案可能很大，只需要返回 答案 mod 109?+ 7 的值。

//示例 1:

//输入: n = 3, k = 0
//输出: 1
//解释: 
//只有数组 [1,2,3] 包含了从1到3的整数并且正好拥有 0 个逆序对。
//示例 2:

//输入: n = 3, k = 1
//输出: 2
//解释: 
//数组 [1,3,2] 和 [2,1,3] 都有 1 个逆序对。

class Solution {
public:
    /*
    4个排列 xxxx  插入5的几种方式
    1. xxxx5 多出0个逆序对，因此有：
        f1(5,k)=f(4,k)
    2. xxx5x 多出1个逆序对，因此有：
        f2(5,k+1)=f(4,k)=> f2(5,k)=f(4,k-1)
    3. xx5xx 多出1个逆序对，因此有：
        f3(5,k+2)=f(4,k)=> f3(5,k)=f(4,k-2)
    4. x5xxx 多出1个逆序对，因此有：
        f4(5,k+3)=f(4,k)=> f4(5,k)=f(4,k-3)
    5. 5xxxx 多出1个逆序对，因此有：
        f5(5,k+4)=f(4,k)=> f5(5,k)=f(4,k-4)
=>
f(5,k) = f1 + f2 + f3 + ... + f5
=>
f(5,k) = f(4,k) + f(4,k-1) + f(4,k-2) + f(4,k-3) + f(4,k-5+1)
=>
f(n,k) = f(n-1,k)+f(n-1,k-1) + f(n-1,k-2) + f(n-1,k-3) + ... + f(n-1,k-n+1)
=>
f(n,k+1) = f(n-1,k+1) + f(n-1,k-1) + f(n-1,k-2) + ... + f(n-1,k-n+2)
=>
f(n,k+1) - f(n,k) = f(n-1,k+1) - f(n-1,k-n+1)
=>
f(n,k+1) = f(n,k) + f(n-1,k+1) - f(n-1,k-n+1)
=>
f(n,k) = f(n,k-1) + f(n-1,k) - f(n-1,k-n)

    两个递推公式
    1. f(n,k) = f(n-1,k)+f(n-1,k-1) + f(n-1,k-2) + f(n-1,k-3) + ... + f(n-1,k-n+1)
    2. f(n,k) = f(n,k-1) + f(n-1,k) - f(n-1,k-n)
    */


    int kInversePairs(int n, int k) {
        vector<vector<long> > dp(n+1, vector<long> (k+1,0));
        const long mod = 1000000007;
        
        dp[0][0] = 1;
        for(int i = 1; i <= n; i++)
        {
            dp[i][0] = 1;
            for(int j = 1; j <= k; j++)
            {
                dp[i][j] = (dp[i-1][j] + dp[i][j-1]) % mod;
                
                if(j >= i)
                    dp[i][j] =( dp[i][j] + mod - dp[i-1][j-i]) % mod;//防止相减后结果是负数
            }
        }

        return dp[n][k];
    }
};
